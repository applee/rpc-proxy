{
// DO NOT EDIT. Code generated by pigeon, run "go generate" to update.

package protobuf

import (
	"bytes"
	"strconv"
	"strings"
	"sort"

    "github.com/golang/protobuf/protoc-gen-go/descriptor"
)

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func ifaceSliceToString(v interface{}) string {
	ifs := toIfaceSlice(v)
	b := make([]byte, len(ifs))
	for i, v := range ifs {
		b[i] = v.([]uint8)[0]
	}
	return string(b)
}
}

Grammar ← __ syntax:Syntax? __ statements:( Statement __ )* (EOF / SyntaxError) {
	proto := &Protobuf{
        Syntax: syntax.(string),
		Dependency: make(map[string]bool),
		Messages: make(map[string]*Message),
		Enums: make(map[string]*Enum),
		Services: make(map[string]*Service),
	}
	stmts := toIfaceSlice(statements)
	for _, st := range stmts {
		switch v := st.([]interface{})[0].(type) {
		case Dependency:
			proto.Dependency[string(v)] = true
		case *Enum:
			proto.Enums[v.Name] = v
		case *Message:
			proto.Messages[v.Name] = v
		case *Service:
			proto.Services[v.Name] = v
		default:
			return nil, fmt.Errorf("parser: unknown value %#v", v)
		}
	}
	err := proto.init()
	return proto, err
}

Syntax ← "syntax" _ '=' _ syntax:Literal _ ';' __ {
    return syntax.(string), nil
}

SyntaxError ← . {
	return nil, errors.New("parser: syntax error")
}

Import ← _ "import" _ file:Literal _ ';' __ {
	return Dependency(file.(string)), nil
}

// do not use `option` and `package`
Statement ← Import / Enum / Message / Service

Enum ← "enum" _ name:Identifier __ '{' __ values:(EnumValue __)* '}' __ {
	vs := toIfaceSlice(values)
	en := &Enum{
		Name: string(name.(Identifier)),
		Values: make(map[string]*EnumValue, len(vs)),
	}
	for _, v := range vs {
		ev := v.([]interface{})[0].(*EnumValue)
		en.Values[ev.Name] = ev
	}
	return en, nil
}

EnumValue ← name:Identifier _ '=' _ value:IntConstant _ ';' __  {
	ev := &EnumValue{
		Name: string(name.(Identifier)),
		Value: value.(int64),
	}
	return ev, nil
}

Message ← "message" _ name:Identifier __ '{' __ body:(MessageBody __)* __ '}' __ {
	m := &Message{
		Name: string(name.(Identifier)),
        Fields: make(map[string]*Field),
		Order: make([]string, 0),
	}

    children := toIfaceSlice(body)
    for _, c := range children {
        switch v := c.([]interface{})[0].(type) {
        case *Field:
            m.Fields[v.Name] = v
			m.Order = append(m.Order, v.Name)
		case []*Field:
			for i := range v {
				m.Fields[v[i].Name] = v[i]
				m.Order = append(m.Order, v[i].Name)
			}
		case *Message:
			v.Name = m.Name + "." + v.Name
			m.NestedMessages = append(m.NestedMessages, v)
		case *Enum:
			v.Name = m.Name + "." + v.Name
			m.NestedEnums = append(m.NestedEnums, v)
        }
    }

	return m, nil
}

MessageBody ← Field / Enum / Message / Oneof / Reserved

Field ← repeated:"repeated"? _ typ:FieldType _ name:Identifier _ '=' _ number:IntConstant _ ';' __ {
	f := &Field{
		Name: string(name.(Identifier)),
		Type: typ.(*Type),
        Tag: number.(int64),
	}
	if repeated != nil {
		f.Repeated = true
	}
	return f, nil
}

Reserved ← "reserved" _ ( Ranges / FieldNames ) _ ';' __
FieldNames ← Literal (',' Literal)*
Ranges ← Range ( _ ',' _ Range)*
Range ← (IntConstant _ "to" _ IntConstant) / IntConstant

Oneof ← "oneof" _ name:Identifier _ '{' __ fields:(Field __)* '}' __ {
    fs := fields.([]interface{})
	ns := string(name.(Identifier))
	o := make([]*Field, len(fs))
    for i, f := range fs {
        fi :=  f.([]interface{})[0].(*Field)
		fi.Oneof = &ns
        o[i] = fi
    }
    return o, nil
}

Map ← "map" _ '<' _ keyType:MapKeyType _ ',' _ valType:FieldType _ '>' _ name:Identifier _ '=' _ number:IntConstant _ ';' __ {
    kt := &Type{Name: keyType.(string)}
	vt := &Type{Name: valType.(string)}
	t := &Type{Name:string(name.(Identifier)), KeyType:kt, ValueType:vt}
	m := &Field{
        Name: string(name.(Identifier)),
        Tag: number.(int64),
		Type: t,
    }
    return m, nil
}

MapKeyType ←  "int32" / "int64" / "uint32" / "uint64" / "sint32" / "sint64" / "fixed32" / "fixed64" / "sfixed32" / "sfixed64" / "bool" / "string" {
    return string(c.text), nil
}

Service ← "service" _ name:Identifier __ '{' __ methods:(Method __)* ('}' / EndOfServiceError) __ {
	ms := methods.([]interface{})
	svc := &Service{
		Name: string(name.(Identifier)),
		Methods: make(map[string]*Method, len(ms)),
	}
	for _, m := range ms {
		mt :=  m.([]interface{})[0].(*Method)
		svc.Methods[mt.Name] = mt
	}
	return svc, nil
}

EndOfServiceError ← . {
	return nil, errors.New("parser: expected end of service")
}

Method ← "rpc" _ name:Identifier _ '(' _ reqStream:("stream" _)? request:Identifier ')' _ "returns" _ '(' _ respStream:("stream" _)? response:Identifier ')' _ ';' __ {
	m := &Method{
		Name: string(name.(Identifier)),
        Request: string(request.(Identifier)),
        Response: string(request.(Identifier)),
	}
    if reqStream!=nil {
        m.ReqStream = true
    }
    if respStream!=nil {
        m.RespStream = true
    }
	return m, nil
}

Option ← "option" _ name:Identifier _ '=' _ val:Constant _ ';' __ 

Constant ← Literal / DoubleConstant / IntConstant / Identifier

BaseType ← "double" / "float" / "int32" / "int64" / "uint32" / "uint64" / "sint32" / "sint64" / "fixed32" / "fixed64" / "sfixed32" / "sfixed64" / "bool" / "string" / "bytes" {
    return string(c.text), nil
}

FieldType ← typ:(BaseType / Identifier) {
    if t, ok := typ.(Identifier); ok {
        return &Type{Name: string(t)}, nil
    }
	return &Type{Name: string(c.text)}, nil
}

IntConstant ← DecimalConstant / OctalConstant / HexConstant

DecimalConstant ← value:('0' / [1-9] DecDigit*) {
    return strconv.ParseInt(string(c.text), 10, 64)
}

OctalConstant ← value:('0' / OctDigit+) {
    return strconv.ParseInt(string(c.text), 8, 64)
}

HexConstant ← value:('0' [xX] HexDigit+) {
    return strconv.ParseInt(string(c.text), 16, 64)
}

DoubleConstant ← [+-]? DecDigit* '.' DecDigit* ( [Ee] [-+]? DecDigit+ )? {
	return strconv.ParseFloat(string(c.text), 64)
}

Literal ← (('"' (`\"` / [^"])* '"') / ('\'' (`\'` / [^'])* '\'')) {
	if len(c.text) != 0 && c.text[0] == '\'' {
		return strconv.Unquote(`"` + strings.Replace(string(c.text[1:len(c.text)-1]), `\'`, `'`, -1) + `"`)
	}
	return strconv.Unquote(string(c.text))
}

Identifier ← (Letter / '_')+ (Letter / DecDigit / [._])* {
	return Identifier(string(c.text)), nil
}

Letter ← [A-Za-z]
DecDigit ← [0-9]
OctDigit ← [0-7]
HexDigit ← [0-9A-Fa-f]
SourceChar ← .
Comment ← SingleLineComment / MultiLineComment
SingleLineComment ← "//" ( !EOL SourceChar )* EOL
MultiLineComment ← "/*" ( !"*/" SourceChar )* "*/" EOL
__ ← ( Whitespace / EOL / Comment )*
_ ← Whitespace*
Whitespace ← [ \t\r\n]
EOL ← "\n" / "\r\n"
EOF ← !.
